
### Scheme benchmarks
Convenient whole programs for measuring overhead over known terminating programs.
- [ ] browse (don't know where `put` is defined)
- [ ] collatz-q (open problem)
- [ ] collatz (open problem)
- [ ] conform (`does-conform`)
- [ ] cpstak (can't for now, CPS conflats calls and returns in general)
- [x] ctak
- [x] dderiv
- [x] deriv
- [x] destruct
- [x] div
- [ ] ~~dynamic~~
- [ ] dynamic2 (input)
- [ ] early ((loop) decreases on mutable states)
- [ ] fft ((loop) decreases on mutable states)
- [ ] graphs (imperative loop 1 -> vector size)
- [ ] kanren (`unify-internals`)
- [ ] ~~lattice~~
- [ ] lattice2 (`map` with non-obvious descendence)
- [ ] ~~maze~~
- [ ] maze2 (`lp` involve descending on mutable states)
- [ ] mazefun (`for-aux` goes up from `lo`, fixable with custom ordering)
- [ ] nboyer (`rewrite-args`, looks fixable with custom ordering)
- [ ] nestedloop (`loop6` goes up from lower bound, fixable with custom ordering)
- [x] nfa
- [ ] nqueens (not out of the box, `try-it` needs some different ordering)
- [x] nucleic2 (with custom `<`)
- [ ] nucleic3 (fixble with custom `<` on structs)
- [ ] paraffins (`loop` goes up from lower bound)
- [ ] peval (not even obvious to me)
- [ ] psyntax (looks big)
- [ ] puzzle (weird stuff)
- [ ] ray (took forever with custom `<`, but looks terminating)
- [ ] sboyer (looks fixable with some ordering)
- [ ] ~~scheme-c~~
- [x] scheme-c2
- [ ] ~~scheme-i~~
- [ ] scheme-i2 (looks fixable with loop specialization)
- [ ] ~~scheme~~
- [x] scheme2
- [x] sort1
- [x] tak
- [x] takl (speeded up with custom ordering)
- [x] takr
- [x] takr2
- [ ] traverse (expects `()` same as `#f`)
- [ ] triangle (`ttry` goes up from lower bound)
