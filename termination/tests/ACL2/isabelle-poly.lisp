;; poly? ::= intp
;;        | (cons/c 'inj (cons/c intp poly?))
;;        | (cons/c 'X (cons/c poly? (cons/c intp poly?)))
(defun Pinj (i p) (cons 'inj (cons i p)))
(defun PX (p i q) (cons 'X (cons p (cons i q))))
(defun Pcp (x) (integerp x))
(defun Pinjp (x)
  (and (consp x)
       (equal 'inj (car x))
       (consp (cdr x))
       (integerp (car (cdr x)))))
(defun PXp (x)
  (and (consp x)
       (equal 'X (car x))
       (consp (cdr x))
       (consp (cdr (cdr x)))
       (integerp (car (cdr (cdr x))))))
(defun Pinj-0 (x) (car (cdr x)))
(defun Pinj-1 (x) (cdr (cdr x)))
(defun PX-0 (x) (car (cdr x)))
(defun PX-1 (x) (car (cdr (cdr x))))
(defun PX-2 (x) (cdr (cdr (cdr x))))
;; add : poly? poly? -> intp
(defun add (l r)
  (cond
   ((and (Pcp l) (Pcp r))
    (+ l r))
   ((and (Pcp l) (Pinjp r))
    (Pinj (Pinj-0 r) (add (Pinj-1 r) l)))
   ((and (Pcp l) (PXp r))
    (PX (PX-0 r) (PX-1 r) (add (PX-2 r) l)))
   ((and (Pinjp l) (Pinjp r))
    (let ((x (Pinj-0 l))
          (p (Pinj-1 l))
          (y (Pinj-0 r))
          (q (Pinj-1 r)))
      (cond ((= x y) (Pinj x (add p q)))
            ((< y x) (Pinj y (add (Pinj (- x y) p) q)))
            (t (add r l)))))
   ((and (Pinjp l) (PXp r))
    (let ((x (Pinj-0 l))
          (p (Pinj-1 l))
          (q (PX-0 r))
          (y (PX-1 r))
          (r (PX-2 r))) ; shadowing, careful
      (cond ((= x 0) (add p (PX q y r)))
            ((= x 1) (PX q y (add p r)))
            (t (PX q y (add (Pinj (- x 1) p) r))))))
   ((and (PXp l) (PXp r))
    (let ((p1 (PX-0 l))
          (x (PX-1 l))
          (p2 (PX-2 l))
          (q1 (PX-0 r))
          (y (PX-1 r))
          (q2 (PX-2 r)))
      (cond ((= x y) (PX (add p1 q1) x (add p2 q2)))
            ((< y x) (PX (add (PX p1 (- x y) 0) q1)
                         y
                         (add p2 q2)))
            (t (add r l)))))
   ((and (Pinjp l) (Pcp r))
    (add r l))
   ((and (PXp l) (Pcp r))
    (add r l))
   ((and (PXp l) (Pinjp r))
    (add r l))
   (t #|all ill-typed cases|# 0)))
